\documentclass[a4paper,11pt]{article}
%\documentclass[a4paper,11pt]{article}
%\jtwocolumn


\pagestyle{myheadings}\markboth{2-Edge-Connectivity: \today}{2-Edge-Connectivity: \today}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% packages
\usepackage{graphicx}
\usepackage{epstopdf}
%\usepackage{tabularx}
\usepackage{latexsym}
%\usepackage{pstricks,psfrag}
\usepackage{amsmath,amssymb}
\usepackage{algorithm} %%% for comm. to N-sensei
\usepackage{algpseudocode} %%% for comm. to N-sensei
% \usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\usepackage{tikz}
\usepackage{xcolor}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% newcommand
%\renewcommand{\mid}{:~}
\newcommand{\secref}[1]{Section~\ref{sec:#1}}
\newcommand{\tabref}[1]{Table~\ref{tab:#1}}
\newcommand{\figref}[1]{Figure~\ref{fig:#1}}
\newcommand{\corref}[1]{Corollary~\ref{cor:#1}}
\newcommand{\lemref}[1]{Lemma~\ref{lem:#1}}
\newcommand{\propref}[1]{Proposition~\ref{prop:#1}}
\newcommand{\thmref}[1]{Theorem~\ref{thm:#1}}

\newcommand{\bbZ}{{\mathbb Z}}
\newcommand{\bbR}{{\mathbb R}}
\newcommand{\MS}{{\mathcal S}}
\newcommand{\MC}{{\mathcal C}}

\newcommand{\vc}[1]{\mbox{\boldmath$ #1 $}}
\newcommand{\myhline}{
\noindent
\begin{tabular}{p{0.97\textwidth}}
\\\hline
\end{tabular}}
\newcommand{\tab}{\hspace*{1em}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% newtheorem
\newtheorem{cor}{Corollary}
\newtheorem{lem}{Lemma}
\newtheorem{prop}{Proposition}
\newtheorem{thm}{Theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% newenvironment
\newenvironment{proof}{\medskip
  \noindent{\scshape Proof:}}{\quad $\Box$\medskip}

\newenvironment{myframe}{\begin{trivlist}\item[]
    \hrule
    \hbox to \linewidth\bgroup
    \advance\linewidth by -30pt
    \hsize=\linewidth
    \vrule\hfill
    \vbox\bgroup
    \vskip15pt
    \def\thempfootnote{\arabic{mpfootnote}}
    \begin{minipage}{\linewidth}}{%
    \end{minipage}\vskip15pt
    \egroup\hfill\vrule
    \egroup\hrule
\end{trivlist}}

\algrenewcommand{\algorithmicrequire}{\textbf{Input: }}
\algrenewcommand{\algorithmicensure}{\textbf{Output: }}

\long\def\invis#1{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% style definitions
%
% following setting makes 3cm spaces for top and bottom, and
% 2.5cm spaces for left and right
%
                                         % default setting
\setlength{\oddsidemargin}{22pt}         % 62pt
\setlength{\evensidemargin}{22pt}        % 62pt
\setlength{\headheight}{12pt}            % 12pt
\setlength{\textheight}{662pt}           % 592pt
\setlength{\marginparsep}{10pt}          % 10pt
\setlength{\footskip}{30pt}              % 30pt
\setlength{\hoffset}{-13pt}              % 0pt
\setlength{\paperwidth}{597pt}           % 597pt
\setlength{\topmargin}{20pt}             % 20pt
\setlength{\headsep}{25pt}               % 25pt
\setlength{\textwidth}{427pt}            % 327pt
\setlength{\marginparwidth}{106pt}       % 106pt
\setlength{\marginparpush}{5pt}          % 5pt
\setlength{\voffset}{-37pt}              % 0pt
\setlength{\paperheight}{845pt}          % 845pt


% 1 inch = 2.54 cm = 72.27 pt

\renewcommand{\baselinestretch}{1.20}
% \setlength{\columnsep}{1.0cm}

\usepackage{xspace}
\newcommand{\lbe}{\mathit{lbe}}
\newcommand{\lbeTarget}{\mathit{lbeTarget}}
\newcommand{\Cov}{\mathit{Cov}}
\newcommand{\CovMult}{\mathit{CovMult}}
\newcommand{\CovSrc}{\mathit{CovSrcMult}}
\newcommand{\SrcExc}{\mathit{SrcExc}}
\newcommand{\Nil}{\textsc{Nil}\xspace}

\usepackage[british,american]{babel}
\newif\ifbritish
% \britishtrue   % or false
\makeatletter
\addto\captionsbritish{\britishtrue}
\addto\captionsamerican{\britishfalse}
\makeatother
\usepackage{mfirstuc}
\newcommand{\engvariation}[2]{%
  \ifbritish
    #1%
  \else
    #2%
  \fi\xspace
}

\newcommand{\neighbour}[0]{\engvariation{neighbour}{neighbor}}
\newcommand{\Neighbour}[0]{\MFUsentencecase{\neighbour}}

\newcommand{\initialise}[0]{\engvariation{initialise}{initialize}}
\newcommand{\Initialise}[0]{\MFUsentencecase{\initialise}}


\newif\ifhyphenationafternon
\hyphenationafternonfalse
\newcommand{\hyphenvariation}[2]{%
  \ifhyphenationafternon
    #1%
  \else
    #2%
  \fi\xspace
}

\newcommand{\nonzero}{\hyphenvariation{non-zero}{nonzero}}
\newcommand{\nonnegative}{\hyphenvariation{non-negative}{nonnegative}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% title information
\title{Simpler Computation of Minimal Removable Sets in 2-Edge-Connected Systems for Undirected Graphs}
\author{SHOTA, Kan\and HARAGUCHI, Kazuya}
%\date{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% document
\begin{document}
% \selectlanguage{american}
\selectlanguage{british}
\maketitle

\section{Introduction}
\label{sec:intro}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
\label{sec:prel}
Throughout the paper, we assume that a graph is simple and undirected.
% We also assume that a \nonnegative integer $k$ is given. 

For a graph $G=(V,E)$ with a vertex set $V$
and an edge set $E$,
we may abbreviate an edge $\{u,v\} \in E$ as $uv$ (or equivalently $vu$)
for simplicity.
For a vertex $v \in V$, we denote by $N_G(v)$ the set of {\neighbour}s of $v$. 
For $S \subseteq V$, we denote by $G[S]$ the subgraph of $G$
induced by $S$.
We denote by $G-S$ the subgraph obtained by
removing $S$ and all edges to incident to $S$,
that is, $G - S = G[V-S]$.
If $S = \{v\}$,
then we simply write $G-v$ instead of $G - \{v\}$.


% DFS-Tree
A \emph{DFS-tree} of a connected undirected graph~$G = (V,E)$
is a spanning tree~$T$ obtained by performing a depth-first search (DFS) on $G$.
We root $T$ at an arbitrary vertex $r \in V$.
% Subtree
For each $v\in V$, we denote by $T_v$ the subtree of $T$
rooted at $v$.

An edge in $E$ is called a \emph{tree edge} if it belongs to $T$,
and a \emph{back edge} otherwise.
%
For $u,v \in V$,
we say that $u$ is an \emph{ancestor} of $v$
if $u$ lies on the unique $r$--$v$ path in $T$.
Moreover, if $u$ is an ancestor of $v$ and $u \neq v$,
then we say that $u$ is a \emph{proper ancestor} of $v$,
and $v$ is correspondingly
a (\emph{proper}) \emph{descendant} of $u$.
If $uv$ is a tree edge and $u$ is an ancestor of $v$,
then $u$ is the \emph{parent} of $v$;
we denote this by $\pi(v)=u$.

% DFS-index
During the DFS,
each vertex is assigned a unique integer called \emph{DFS-index},
which records the order in which the DFS visits the vertices.
For $v \in V$, we denote its DFS-index by $\mathit{dfsId}(v)$.
Every vertex has a smaller DFS-index than any of its descendants.

% orientation of edges
We may orient edges based on the DFS-tree $T$:
for a tree edge $\pi(v)v$, we orient it from $\pi(v)$ to $v$; and
for a back edge $xy$, we orient it from the descendant to the ancestor.
We may write $(u,v)$ and $(x,y)$ to indicate the orientation of edge $uv$ and $xy$,
and refer to it as the \emph{outgoing edge} from $u$
and the \emph{incoming edge} to $v$.

%
We say that a tree edge $\pi(v)v$ is \emph{covered} by a back edge
$e=(x,y)$ if $x$ is a descendant of $v$ and
$y$ is a proper ancestor of $v$
(an ancestor of $\pi(v)$).
In this case, $e$ together with $\pi(v)v$ forms part of a cycle in $G$.
Note that every tree edge is covered by at least one back edge
if $G$ is 2-edge-connected.
For a tree edge $uv$, we denote by
$
\Cov(uv)=\{(x,y)\in E \mid (x,y)\ \text{is a back edge covering}\ uv\}
$
the set of back edges that cover $uv$.
We refer to $\CovMult(uv) := |\Cov(uv)|$ as the \emph{cover multiplicity}
of the tree edge $uv$.
Furthermore, we define the \emph{cover-source multiplicity} of $uv$ to be
$
\CovSrc(uv)=\bigl|\{x \in V(T_v) \mid \text{There is } y \text{ s.t. } (x,y)\in \Cov(uv)\}\bigr|,
$
that is, the number of distinct descendants of $v$
that serve as tails of back edges covering~$uv$.

% longest back edge outgoing from v
For a vertex $x \in V$,
every vertex~$y$ with a back edge $(x, y)$
lies on the unique $\pi(x)$--$r$ path in $T$.
Among such vertices~$y$,
let $y^*$ be the one with the smallest DFS-index,
that is, the one closest to the root $r$ in $T$.
We call the back edge $x y^*$ the \emph{longest back edge outgoing from $x$}
and denote it by $\lbe(x)$ and $y^*$ by $\lbeTarget(x)$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Computation of Cover multiplicities}
\label{sec:cov_mult}
In this section, we present an $O(n+m)$-time algorithm
to compute the cover multiplicity and the cover-source multiplicity
for all tree edges in a 2-edge-connected undirected graph $G=(V,E)$
with $n=|V|$ and $m=|E|$.

Since the two multiplicities can be computed in a similar manner,
we here describe the algorithm for computing the cover multiplicities;
the cover-source multiplicities can be computed with a minor modification
as described at the end of this section.

In this section, we assume that a DFS-tree $T$ of $G$,
rooted at an arbitrary vertex $r \in V$, is already given.
The algorithm consists of two phases.
In the first phase, we process each back edge to update an auxiliary
value called \emph{cover-delta value} associated with its endpoints.
%(Algorithm~\ref{alg:preproc_backedge}).
In the second phase, we traverse $T$ in a depth-first manner to aggregate these values
along the tree and compute the multiplicity for each tree edge
(Algorithm~\ref{alg:cov_mult}).
% The details are described below.

In order to compute the cover multiplicities,
we define the \emph{cover-delta value} $\delta(v)$ for each vertex $v \in V$ as follows:
\[
\delta(v)
:= \big| \{(v,y) \mid (v,y) \text{ is a back edge}\} \big| - \big| \{(x,v) \mid (x,v) \text{ is a back edge}\} \big|.
\]
Equivalently, 
if we orient all back edges from descendants to ancestors as described in \secref{prel}
and remove all tree edges,
then $\delta(v)$ equals the outdegree minus the indegree of $v$ in the resulting directed graph.
The cover-delta values satisfy a fundamental relation with the cover
multiplicity, which we show below.

\begin{lem}
  \label{lem:delta_cov}
  For any tree edge $(u,v)$ of $G$,
  the cover multiplicity of $(u,v)$ is equal to the sum of
  the cover-delta values for all vertices in $T_v$:
  \[
  \CovMult(uv) = \sum_{w \in V(T_v)} \delta(w).
  \]
\end{lem}
\begin{proof}
  By the definition of $\delta$,
  every back edge $(x,y)$ contributes $+1$ to $\delta(x)$ and $-1$ to $\delta(y)$.
  We examine how such a back edge contributes to the sum~$\sum_{w \in V(T_v)} \delta(w)$.

  If $x \in V(T_v)$ and $y \not\in V(T_v)$,
  then $(x,y)$ covers $uv$ and contributes $+1$ to the sum.
  If both $x$ and $y$ belong to $V(T_v)$,
  then $(x,y)$ does not cover $uv$ and
  its $+1$ and $-1$ contributions cancel within $T_v$,
  yielding a total contribution of $0$.
  If neither $x$ nor $y$ is in $T_v$,
  then $(x,y)$ does not cover $uv$ and again contributes $0$ to the sum.
  Since $y$ is a proper ancestor of $x$,
  the case with $x \not\in V(T_v)$ and $y \in V(T_v)$ cannot occur.

  Therefore, the only back edges that contribute a \nonzero amount are those
  that cover $uv$,
  and each such edge contributes exactly $+1$.
\end{proof}

In order to compute the cover-delta values for all vertices in $V$,
we can process each back edge $(x,y)$ of $G$
and increment $\delta(x)$ by 1 and decrement $\delta(y)$ by 1.
This can be done in $O(n+m)$ time
by performing a DFS on $G$ to obtain its DFS-tree $T$
and then processing all back edges of $G$.

The second phase computes the cover multiplicities for all tree edges
by aggregating the cover-delta values along the DFS-tree $T$.
The details are shown in Algorithm~\ref{alg:cov_mult}.


% Algo I
\begin{algorithm}[t]
  \caption{Computation of Cover Multiplicities by DFS}
  \label{alg:cov_mult}
  \begin{algorithmic}[1]
    \Require A 2-edge-connected undirected graph $G=(V,E)$,
    a DFS-tree $T$ of $G$ rooted at $r \in V$,
    and
    the cover-delta values $\delta$ for all vertices in $V$
    \Ensure The cover multiplicities of all tree edges
    \State $\CovMult := {}$ an array from tree edges to integers;
    \For{\textbf{each} child $w$ of the root $r$ in $T$}
      \State Execute \Call{CoverMultiplicity-DFS}{$w$}
    \EndFor;
    \State \textbf{output} $\CovMult(e)$ for all tree edges $e$ in $E(T)$
    
    \\\Procedure{CoverMultiplicity-DFS}{$v$}
    \State $\CovMult(\pi(v)v) := \delta(v)$;
    \For{\textbf{each} child $w$ of $v$ in $T$}
      \State Execute \Call{CoverMultiplicity-DFS}{$w$};
      \State $\CovMult(\pi(v)v) := \CovMult(\pi(v)v) + \CovMult(vw)$
    \EndFor
    % \State \textbf{return} $\CovMult(uv)$;
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

% % Algo II
% \begin{algorithm}[t]
%   \caption{Preprocessing Back Edges}
%   \label{alg:preproc_backedge}
%   \begin{algorithmic}[1]
%     \Require A 2-edge-connected undirected graph $G=(V,E)$
%     and its DFS-tree $T$ rooted at $r \in V$
%     \Ensure The cover-delta values $\delta$ for all vertices in $V$
%     \State Initialize $\delta(v) := 0$ for all $v \in V$;
%     \For{\textbf{each} back edge $(x,y)$ of $G$}
%     \label{codeline:backedge_loop}
%       \State $\delta(x) := \delta(x) + 1$;
%       \State $\delta(y) := \delta(y) - 1$
%     \EndFor;
%     \State \textbf{return} $\delta$
%   \end{algorithmic}
% \end{algorithm}

% The overall algorithm is as follows:
% \begin{enumerate}
% \item Execute Algorithm~\ref{alg:preproc_backedge} to compute
%   the cover-delta values for all vertices in $V$.
% \item Execute Algorithm~\ref{alg:cov_mult} with the tree edge
%   incident to the root $r$ to compute the cover multiplicities
%   for all tree edges in $T$.
% \end{enumerate}


\begin{lem}
  \label{lem:cov_mult}
  Given a 2-edge-connected undirected graph $G=(V,E)$
  with $n=|V|$ and $m=|E|$,
  its DFS-tree $T$ rooted at $r \in V$, and 
  the cover-delta values $\delta$ for all vertices in $V$,
  Algorithm~\ref{alg:cov_mult} computes the cover multiplicities
  for all tree edges in $O(n)$ time.
\end{lem}
\begin{proof}
  By \lemref{delta_cov},
  it suffices to show that
  Algorithm~\ref{alg:cov_mult} correctly computes
  the sum of the cover-delta values for all vertices in $T_v$.

  We first show the case with $v$ being a leaf.
  In this case, since there is no child of $v$ in $T$,
  the algorithm returns $\CovMult(uv) = \delta(v)$.
  
  Next, we consider the case other than the leaf case. 
  We assume that, for any child $w$ of $v$ in $T$,
  \Call{CoverMultiplicity-DFS}{$w$} correctly computes
  the sum of the cover-delta values for all vertices in $T_w$.
  Then, the algorithm computes
  \[
  \delta(v) + \sum_{w \text{:~child of } v} \sum_{z \in V(T_w)} \delta(z)
  = \sum_{z \in V(T_v)} \delta(z)
  \]
  that is the sum of the cover-delta values for all vertices in $T_v$.

  We visit each vertex exactly once,
  and consider all tree edges exactly once,
  which means we can correctly compute the cover multiplicities for all tree edges.
  Since we traverse only tree edges in $T$,
  we can execute the algorithm in $O(n)$ time.
\end{proof}

% If we want to compute the cover-source multiplicities,
% we can modify Algorithm~\ref{alg:preproc_backedge}
% so that, in line \ref{codeline:backedge_loop} of Algorithm~\ref{alg:preproc_backedge},
% we only consider the longest back edges outgoing from each vertex.
To compute the cover-source multiplicities,
we modify the definition of the cover-delta value so that
it accounts only for the longest outgoing back edges.
We define the \emph{cover-source-delta} value $\delta_{\text{src}}(v)$
to be
\[
\delta_{\text{src}}(v)
:=
\left.\begin{cases}
1 & \text{if } \lbe(v) \text{ exists} \\
0 & \text{otherwise}
\end{cases}
\right\}
% \big| \{\lbeTarget(x) \mid \lbe(x) \text{ exists}\} \big|
- \big| \{x \in V \mid \lbe(x) = (x,v)\} \big|.
\]
Equivalently,
if we orient only the longest back edges from descendants to ancestors
and remove all the other edges,
then $\delta_{\text{src}}(v)$ equals the outdegree minus the indegree of $v$ in the resulting directed graph.
Then, by a similar argument to \lemref{delta_cov},
we can show that
\[
\CovSrc(uv) = \sum_{w \in V(T_v)} \delta_{\text{src}}(w).
\]
Thus, by replacing $\delta$ with $\delta_{\text{src}}$ in Algorithm~\ref{alg:cov_mult},
we can compute the cover-source multiplicities for all tree edges.


Therefore, we obtain the following theorem that 
\engvariation{summarises}{summarizes} the results in this section.

\begin{thm}
  \label{thm:cov_mult}
  Given a 2-edge-connected undirected graph $G=(V,E)$
  with $n=|V|$ and $m=|E|$,
  we can compute the cover multiplicity and the cover-source multiplicity
  for all tree edges in $G$ in $O(n+m)$ time.
\end{thm}
\begin{proof}
  We first perform a DFS on $G$ to obtain its DFS-tree $T$
  rooted at an arbitrary vertex $r \in V$ in $O(n+m)$ time.
  Next, we process all back edges of $T$
  to compute the cover-delta values~$\delta$ or cover-source-delta values~$\delta_{\text{src}}$ for all vertices in $V$ in $O(n+m)$ time.
  Finally, we execute Algorithm~\ref{alg:cov_mult}
  with each tree edge $(r, v)$ incident to the root $r$
  to compute the cover multiplicities for all tree edges in $T$.
  By \lemref{cov_mult},
  this step takes $O(n)$ time.
  Thus, the total time complexity is $O(n+m)$.
\end{proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Properties of Minimal Removable Sets}
\label{sec:mrs_props}
\subsection{DFS-Tree Leaf MinRSs}
\label{sec:leaf_mrs}
In this section, we consider MinRSs that consist of only leaves of a DFS-tree.

We first show a basic property of leaves in a DFS-tree
of a 2-edge-connected undirected graph.
\begin{lem}
  \label{lem:leaf_not_ap}
  Let $G=(V,E)$ be a 2-edge-connected undirected graph with $|V|\geq 3$
  and
  $T$ be a DFS-tree of $G$ rooted at $r\in V$.
  Any leaf of $T$ is not an articulation point of $G$.
\end{lem}
\begin{proof}
  Since $T$ is a spanning tree of $G$,
  every path in $T$ also exists in $G$.
  For any leaf $v\in V$ of $T$,
  $T - v$ is connected.
  Thus, $G - v$ is also connected,
  which means that $v$ is not an articulation point of $G$.
\end{proof}


%


% \begin{lem}
%   \label{lem:leaf_mrs}
%   Let $G=(V,E)$ be a 2-edge-connected undirected graph with $|V|\geq 3$ and,
%   $T$ be a DFS-tree of $G$ rooted at $r\in V$.
%   For each leaf $v$, $\{v\}$ is a MinRS of $G$ if and only if
%   the following two conditions hold:
%   \begin{itemize}
%   \item[\rm (i)] $\pi(v)$ has degree at least 3 in $G$; and
%   % \item[\rm (ii)] for any back edge $vu$,
%   % any tree edge on the $u,\pi(v)$-path in $T$ is covered by
%   % some back edge outgoing from other vertex than $v$. 
%   \item[\rm (ii)] let $\lbe(v)=(v,u^*)$,
%     then, for any tree edge $(x,y)$ on the $u^*,\pi(v)$-path in $T$,
%     there exists a back edge outgoing from a vertex in $T_y - v$
%     that covers $(x,y)$.
%   \end{itemize}
% \end{lem}
% \begin{proof}
%   ($\Longrightarrow$)
%   We show by contraposition.
%   Suppose that either (i) or (ii) does not hold.
%   If (i) does not hold, then
%   $\pi(v)$ has degree 1 in $G - v$,
%   which means that $G - v$ is not 2-edge-connected.
%   If (ii) does not hold,
%   then there exists a tree edge $(x,y)$ on the $u^*,\pi(v)$-path in $T$
%   that is not covered by any back edge outgoing from other vertex than $v$.
%   Since any vertex in $T_y - v$ cannot have a back edge to
%   a proper ancestor of $x$ in $G - v$,
%   which means that $xy$ is a bridge in $G - v$.
%   Thus, in either case, $G - v$ is not 2-edge-connected.
  
%   % \medskip
%   ($\Longleftarrow$)
%   We suffice to show that $G - v$ is 2-edge-connected.
%   By \lemref{leaf_not_ap},
%   $G - v$ is connected.
%   We show that there is no bridge in $G - v$.
%   Every back edge $(x, y)$ with $x, y \neq v$ is not a bridge in $G - v$,
%   since $xy$ and the $y,x$-path in $T$ form a cycle in $G - v$.
%   Next, we consider tree edges in $G - v$.
%   For any tree edge not on the $u^*,\pi(v)$-path in $T$,
%   the covering back edge still exists in $G - v$,
%   which means that such a tree edge is not a bridge in $G - v$.
%   For any tree edge $(x,y)$ on the $u^*,\pi(v)$-path in $T$,
%   by (ii),
%   there exists a back edge outgoing from a vertex in $T_y - v$
%   that covers $(x,y)$,
%   which means that such a tree edge is not a bridge in $G - v$.
%   Thus, there is no bridge in $G - v$,
%   and hence, $G - v$ is 2-edge-connected.
% \end{proof}


\begin{lem}
  \label{lem:leaf_mrs}
  Let $G=(V,E)$ be a 2-edge-connected undirected graph with $|V|\geq 3$ and
  $T$ be a DFS-tree of $G$ rooted at $r\in V$.
  Let $x$ be a leaf of $T$ %that has back edges
  and $y :=\lbeTarget(x)$.
  Then, $\{x\}$ is a MinRS of $G$ if and only if,
  for any tree edge $(u,v)$ on the $y$--$\pi(x)$ path in $T$,
  there exists a back edge outgoing from some vertex in $T_v - x$
  that covers $(u,v)$. 
\end{lem}
\begin{proof}
  ($\Longrightarrow$)
  We show by contraposition.
  Suppose that there exists a tree edge $(u,v)$ on the $y$--$\pi(x)$ path in $T$
  that is not covered by any back edge outgoing from a vertex  other than $x$.
  Any vertex in $T_v - x$ cannot have a back edge to
  a proper ancestor of $u$ in $G - x$,
  which means that $uv$ is a bridge in $G - x$.
  Thus, $G - x$ is not 2-edge-connected.

  % \medskip
  ($\Longleftarrow$)
  It suffices to show that $G - x$ is 2-edge-connected.
  By \lemref{leaf_not_ap},
  $G - x$ is connected.
  We show that there is no bridge in $G - x$.
  Every back edge $(x', y') \in E \setminus E(T)$
  with $x', y' \neq x$ is not a bridge in $G - x$,
  since $x'y'$ and the $y'$--$x'$ path in $T$ form a cycle in $G - x$.
  Next, we consider tree edges in $G - x$.
  For any tree edge not on the $y$--$\pi(x)$-path in $T$,
  no covering back edge disappears by removing $x$ from $G$,
  % still exists in $G - x$,
  which means that such a tree edge is not a bridge in $G - x$.
  For any tree edge $(u, v)$ on the $y$--$\pi(x)$-path in $T$,
  by the assumption,
  there exists a back edge outgoing from a vertex in $T_v - x$
  that covers $(u,v)$,
  which means that such a tree edge is not a bridge in $G - x$.
  Thus, there is no bridge in $G - x$,
  and hence, $G - x$ is 2-edge-connected.
\end{proof}


Here, we introduce the \emph{source-exclusive coverage set}~$\SrcExc_v$ of each vertex $v \in V$,
defined to be the set of tree edge $e$ in $T$ such that
$\CovSrc(e) = 1$ and $e$ is covered by
only back edges outgoing from $v$.
Or equivalently,
if $e \in \SrcExc_v$,
then $e$ is covered by back edges outgoing from $v$,
and no back edge outgoing from any other vertex covers $e$.
Any tree edge in $\SrcExc_v$ must be on the $\lbeTarget(v)$--$\pi(v)$ path in $T$.

By \lemref{leaf_mrs},
$\{x\}$ is a MinRS of $G$ if and only if $\SrcExc_x = \{\pi(x)x\}$.
Thus, in order to find all MinRSs consisting of only leaves of $T$,
it suffices to compute $\SrcExc_v$ for each leaf $v$ of $T$.
This can be done by the Algorithm~\ref{alg:treeedge_to_backedge}
that traverses $T$ in a depth-first manner
and collects tree edges with cover-source multiplicity 1
covered by back edges outgoing from each leaf.
Before describing the algorithm,
there are some lemmas to show its correctness.

\begin{lem}
  \label{lem:leaf_longest_backedge_coverage}
  Let $G=(V,E)$ be a 2-edge-connected undirected graph and
  $T$ be a DFS-tree of $G$ rooted at $r\in V$.
  Let $l$ be a leaf of $T$ and
  $v \neq r$ be an ancestor of $l$ in $T$.
  The tree edge $\pi(v)v$ is covered by the longest back edge $\lbe(l)$ outgoing from $l$
  if and only if $\mathit{dfsId}(\lbeTarget(l)) < \mathit{dfsId}(v)$.
\end{lem}
\begin{proof}
  Let $y := \lbeTarget(l)$.
  Since both $y$ and $v$ are on the unique $\pi(l)$--$r$ path in $T$,
  $y$ is an ancestor or a descendant of $v$.
  We have $\mathit{dfsId}(y) < \mathit{dfsId}(v)$
  if and only if $y$ is a proper ancestor of $v$.
  By the definition of coverage,
  $\pi(v)v$ is covered by $\lbe(l)$
  if and only if $y$ is a proper ancestor of $v$.
\end{proof}

\begin{lem}
  \label{lem:leaves_longest_backedge_coverage}
  Let $G=(V,E)$ be a 2-edge-connected undirected graph and
  $T$ be a DFS-tree of $G$ rooted at $r\in V$.
  Let $l, l'$ be distinct leaves of $T$ and
  $v \neq r$ be a common ancestor of $l$ and $l'$ in $T$.
  We assume that $\mathit{dfsId}(\lbeTarget(l)) \geq \mathit{dfsId}(\lbeTarget(l'))$.
  If a tree edge $\pi(v)v$ is covered by the longest back edge $\lbe(l)$ outgoing from $l$,
  then $\pi(v)v$ is also covered by the longest back edge $\lbe(l')$ outgoing from $l'$.
\end{lem}
\begin{proof}
  By \lemref{leaf_longest_backedge_coverage},
  since $\pi(v)v$ is covered by $\lbe(l)$,
  we have $\mathit{dfsId}(\lbeTarget(l)) < \mathit{dfsId}(v)$.
  By the assumption,
  $\mathit{dfsId}(\lbeTarget(l')) \leq \mathit{dfsId}(\lbeTarget(l)) < \mathit{dfsId}(v)$ holds.
  By \lemref{leaf_longest_backedge_coverage} again,
  $\pi(v)v$ is also covered by $\lbe(l')$.
\end{proof}

We are now ready to describe Algorithm~\ref{alg:treeedge_to_backedge}
that computes $\SrcExc_v$ for each leaf $v$ of $T$.

% ALGO
\begin{algorithm}[t]
  \caption{Computation of source-exclusive coverage set for each leaf}
  \label{alg:treeedge_to_backedge}
  \begin{algorithmic}[1]
    \Require A 2-edge-connected undirected graph $G=(V,E)$,
    DFS-tree $T$ of $G$ rooted at $r \in V$, and
    the cover-source multiplicities $\CovSrc$ for all tree edges in $T$
    \Ensure The source-exclusive coverage sets $\SrcExc_v$ for all leaves $v$ of $T$
    \State \Initialise $\SrcExc_v := \emptyset$ for all leaves $v$ of $T$;
    \For{\textbf{each} child $w$ of the root $r$ in $T$}
      \State Execute \Call{TreeEdgeToBackEdge}{$w$}
    \EndFor;
    \State \textbf{output} $\SrcExc_v$ for all leaves $v$ of $T$
    \State


    \Procedure{TreeEdgeToBackEdge}{$v$}
    % \State $l := \Nil$;
    % \If{$v$ is a leaf}
    %   \State $l := v$
    % \EndIf;
    \State $l := \begin{cases}
      v & \text{if } v \text{ is a leaf} \\
      \Nil & \text{otherwise}
    \end{cases}$;
    \For{\textbf{each} child $w$ of $v$ in $T$}
      \State Execute \Call{TreeEdgeToBackEdge}{$w$};
      \State Let $l'$ be the returned leaf;
      \If{$l' \neq \Nil$ and [$l = \Nil$ or $ \mathit{dfsId}(\lbeTarget(l')) < \mathit{dfsId}(\lbeTarget(l))$]}
      \label{codeline:update_l}
        \State $l := l'$
      \EndIf
    \EndFor;
    \If{$l \neq \Nil$ and $\mathit{dfsId}(\lbeTarget(l)) \geq \mathit{dfsId}(v)$}\label{codeline:check_l}
    \State $l := \Nil$
    \EndIf;
    
    \State $\SrcExc_l := \SrcExc_l \cup \{\pi(v)v\}$ \textbf{if} $\CovSrc(\pi(v)v) = 1$ and $l \neq \Nil$;
    \State \textbf{return} $l$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{lem}
  \label{lem:treeedge_to_backedge}
  Given a 2-edge-connected undirected graph $G=(V,E)$
  with $n=|V| \geq 3$ and $m=|E|$,
  its DFS-tree $T$ rooted at $r \in V$, and 
  the cover-source multiplicities $\CovSrc$ for all tree edges in $T$,
  Algorithm~\ref{alg:treeedge_to_backedge} computes $\SrcExc_v$
  for each leaf $v$ of $T$
  in $O(n)$ time.
\end{lem}
\begin{proof}
  (Correctness)
  We first show that the case with $v$ being a leaf.
  In this case, since there is no child of $v$ in $T$,
  the algorithm returns $l = v$.
  Moreover, $\pi(l)l$ is clearly covered by $\lbe(l)$ and
  no longest back edge outgoing from other leaf covers $\pi(l)l$.
  This means that, if $\CovSrc(\pi(l)l) = 1$,
  then $\pi(l)l \in \SrcExc_l$ holds.

  Next, we consider the case other than the leaf case. 
  We assume that, for any child $w$ of $v$ in $T$,
  \Call{TreeEdgeToBackEdge}{$w$} correctly computes
  a leaf $l'$ such that
  every tree edge in $\SrcExc_{l'}$ is covered by $\lbe(l')$
  and no longest back edge outgoing from other leaf covers such tree edges.
  By \lemref{leaves_longest_backedge_coverage},
  we need to consider only the leaf $l'$ with the smallest
  $\mathit{dfsId}(\lbeTarget(l'))$ among such leaves $l'$ returned from children of $v$.
  The algorithm correctly selects such a leaf $l$ (line \ref{codeline:update_l}).
  If $\mathit{dfsId}(\lbeTarget(l)) \geq \mathit{dfsId}(v)$,
  then, by \lemref{leaf_longest_backedge_coverage},
  no longest back edge outgoing from $l$ covers $\pi(v)v$,
  and hence, we set $l := \Nil$ (line \ref{codeline:check_l}).
  Then, if $l \neq \Nil$, then
  the tree edge $\pi(v)v$ is covered by $\lbe(l)$.
  Therefore, if $\CovSrc(\pi(v)v) = 1$ and $l \neq \Nil$,
  then we can insert $\pi(v)v$ into $\SrcExc_l$.

  (Time complexity)
  We visit each vertex exactly once,
  and consider all tree edges exactly once,
  which means we can compute $\SrcExc_v$ for all leaves $v$ of $T$.
  Since we traverse only tree edges in $T$,
  we can execute the algorithm in $O(n)$ time.
\end{proof}

\begin{thm}
  \label{thm:leaf_mrs}
  Given a 2-edge-connected undirected graph $G=(V,E)$
  with $n=|V|$ and $m=|E|$,
  we can compute all MinRSs consisting of only leaves of a DFS-tree $T$
  in $O(n+m)$ time.
\end{thm}
\begin{proof}
  % Note that we asuume that a graph is simple throughout this paper.
  Note that we assume that a graph has no parallel edges throughout this paper.
  If $|V| < 3$, i.e., $G$ consists of only one vertex,
  then $G$ has no MinRS.
  Thus, we assume that $|V| \geq 3$.
  As the given graph is 2-edge-connected,
  each tree edge is covered by at least one back edge.
  By \lemref{leaf_mrs}, $\{v\}$ is a MinRS of $G$ if and only if
  for any tree edge is covered by back edges outgoing from vertices other than $v$,
  which means that $\CovSrc(e) \geq 2$.
  Thus, we can check whether $\{v\}$ is a MinRS of $G$
  by checking whether $\SrcExc_v$ is equal to $\{\pi(v)v\}$ ot not.
  By \thmref{cov_mult},
  we can compute the cover-source multiplicities for all tree edges
  in $O(n+m)$ time.
  By \lemref{treeedge_to_backedge},
  we can compute the sets $\SrcExc_v$ for all leaves $v$ of $T$
  in $O(n)$ time.
  Thus, we can compute all MinRSs consisting of only leaves of $T$
  in $O(n+m)$ time.
\end{proof}

\subsection{Maximal 2-deg Path MinRSs}
\label{sec:2deg_path_mrs}
TODO

\subsection{Single Vertex Degree at Least 3 MinRSs}
\label{sec:single_vertex_deg3_mrs}
TODO

\subsection{Reuse of DFS-tree and Covering Information}
\label{sec:reuse_dfs_cov}
TODO

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \clearpage
% \input{unused_lemmas.tex}

\end{document}


